#tag ClassProtected Class FGThumbnailCanvasInherits FGThumbnailCanvasSuper	#tag Event		Function ConstructContextualMenu(base as MenuItem, x as Integer, y as Integer) As Boolean		  //		End Function	#tag EndEvent	#tag Event		Function ContextualMenuAction(hitItem as MenuItem) As Boolean		  //		End Function	#tag EndEvent	#tag Event		Sub GotFocus()		  mInFocus = true		  GotFocus()		End Sub	#tag EndEvent	#tag Event		Function KeyDown(Key As String) As Boolean		  dim handled as boolean = false		  		  if Asc(key) = UpKeyCode then		    SelectedIndex = SelectedIndex - Columns		    handled = true		  elseif Asc(key) = DownKeyCode then		    SelectedIndex = SelectedIndex + Columns		    handled = true		  elseif Asc(key) = LeftKeyCode then		    SelectedIndex = SelectedIndex - 1		    handled = true		  elseif Asc(key) = RightKeyCode then		    SelectedIndex = SelectedIndex + 1		    handled = true		  end if		  		  // Scroll to selection		  if handled then		    if SelectedIndex < 0 then SelectedIndex = 0		    if SelectedIndex> Thumbnails.Ubound then SelectedIndex = Thumbnails.Ubound		    if not Thumbnails(SelectedIndex).Visible then		      ScrollToSelectedIndex()		    else		      Update()		    end if		    SelectionChanged()		    call ClickedThumbnail(Thumbnails(SelectedIndex))		  end if		  		  return handled or KeyDown(key)		  		End Function	#tag EndEvent	#tag Event		Sub LostFocus()		  mInFocus = false		  LostFocus()		  		End Sub	#tag EndEvent	#tag Event		Function MouseDown(X as integer, Y as integer) As boolean		  dim a, index, limit, low, high as integer		  dim madeSelection as boolean		  dim globalX as integer = Left + me.TrueWindow.Left + x		  dim globalY as integer = Top + me.TrueWindow.Top + y		  		  // Make sure the canvas has the focus		  self.SetFocus()		  		  LastMouseX = x		  LastMousey = y		  Dragging = false		  		  // Check only the visible thumbnails		  limit = Visibles.Ubound		  		  for a = 0 to limit		    index = Visibles(a)		    if Thumbnails(index).Hit(x, y) then		      		      // We've clicked on this thumbnail		      if not SelectedThumbnailsDict.HasKey(index) and not (Keyboard.CommandKey or Keyboard.ShiftKey) then		        selectedIndex = -1		      end if		      		      if Keyboard.ShiftKey then ' handle continuous selection		        low = IndexOfLowestSelectedThumbnail()		        high = IndexOfHighestSelectedThumbnail()		        		        if low < 0 then low = index		        if high < 0 then high = index		        		        if index > low and index < High then ' behave Finder-like.  If the click is within the actual selection - deselect		          selectedIndex = -1		          SelectedThumbnailsDict.Value(index) = 0		        else		          SelectRange(min(low, index), max(high, index))		        end if		      else 'non-continous selection		        if SelectedThumbnailsDict.HasKey(index) and Keyboard.CommandKey then ' clicked on a currently selected thumbnail with the Command key held down		          SelectedThumbnailsDict.Remove(index)		        else		          SelectedThumbnailsDict.Value(index) = 0 ' clicked on an unselected thumbnail with the Command key - select it		        end if		      end if		      madeSelection = true		      exit		    end if		  next		  		  if not madeSelection and not (Keyboard.CommandKey or Keyboard.ShiftKey) then		    selectedIndex = -1		  end if		  		  // Update the canvas		  Refresh()		  		  // We let the user decide whether or not to fire the MouseDrag event		  if SelectedThumbnailsDict.Count = 1 and madeSelection then		    return ClickedThumbnail(Thumbnails(SelectedIndex), IsContextualClick, globalX, globalY)		  elseif SelectedThumbnailsDict.Count = 0 then		    return ClickedThumbnail(nil, IsContextualClick, globalX, globalY)		  elseif SelectedThumbnailsDict.Count > 0 and madeSelection then		    return ClickedThumbnail(Thumbnails(SelectedThumbnailsDict.Key(SelectedThumbnailsDict.Count-1)), IsContextualClick, globalX, globalY)		  end if		  		End Function	#tag EndEvent	#tag Event		Sub MouseDrag(X as integer, Y as integer)		  if SelectionCount > 0 and (abs(x-LastMouseX) >= 5 or abs(y-LastMouseY) >= 5) and not dragging then ' make sure we've dragged at least 5 pixels		    Dragging = true		    MouseDrag(x, y, SelectedThumbnails)		  end if		  		End Sub	#tag EndEvent	#tag Event		Sub MouseExit()		  // We've left the canvas so, therefore, can't be over a thumbnail		  if CurrentThumbnailUnderMouseIndex > -1  and CurrentThumbnailUnderMouseIndex <= Thumbnails.Ubound then		    Thumbnails(CurrentThumbnailUnderMouseIndex).UnderMouse = false		    Update(true)		  end if		  		  // Fire the user's event		  MouseExit()		  		End Sub	#tag EndEvent	#tag Event		Sub MouseMove(X As Integer, Y As Integer)		  // Is a thumbnail under the mouse?		  		  dim a, index as integer		  dim newThumbnailUnderMouse as boolean = false		  		  // Check all the visible thumbnails for a hit		  if Visibles.Ubound >= 0 then		    for a = 0 to Visibles.Ubound		      index = Visibles(a)		      if Thumbnails(index).Hit(x, y) then		        // This thumbnail is under the mouse.  Check to see if we need to clear a previously hovered-over thumbnail		        if CurrentThumbnailUnderMouseIndex > -1  and CurrentThumbnailUnderMouseIndex <= Thumbnails.Ubound then		          Thumbnails(CurrentThumbnailUnderMouseIndex).UnderMouse = false		        end if		        mCurrentThumbnailUnderMouseIndex = index		        Thumbnails(index).UnderMouse = true		        newThumbnailUnderMouse = true		        exit		        		      else		        if a = Visibles.Ubound and CurrentThumbnailUnderMouseIndex > -1  and CurrentThumbnailUnderMouseIndex <= Thumbnails.Ubound then		          // We are no longer over a thumbnail		          Thumbnails(CurrentThumbnailUnderMouseIndex).UnderMouse = false		          mCurrentThumbnailUnderMouseIndex = -1		          newThumbnailUnderMouse = true		        end if		      end if		    next a		  end if		  		  if newThumbnailUnderMouse and ForceUpdateOnMouseMove then Update(true) ' force an update		  		  // Fire our custom event		  MouseMove(x, y)		  		End Sub	#tag EndEvent	#tag Event		Sub MouseUp(X as integer, Y as integer)		  dim a as integer		  dim shouldFireSelectionChanged as boolean = false		  		  if SelectionBuffer.Count > 0 then		    for a = 0 to SelectionBuffer.Count-1		      SelectedThumbnailsDict.Value(SelectionBuffer.Key(a)) = 0		    next a		    shouldFireSelectionChanged = true		    SelectionBuffer.Clear()		  end if		  		  Refresh()		  		  // Fire the user's event		  if shouldFireSelectionChanged then SelectionChanged()		End Sub	#tag EndEvent	#tag Event		Function MouseWheel(X As Integer, Y As Integer, deltaX as Integer, deltaY as Integer) As Boolean		  // deltaY is positive if scrolling down, negative if scrolling up		  		  if AllowMouseWheelScrolling then		    if InvertMouseWheelScrollDirection then		      Scroll(-deltaY)		    else		      Scroll(deltaY)		    end if		  end if		  		  // Fire the user's event		  return MouseWheel(x, y, deltaX, deltaY)		  		End Function	#tag EndEvent	#tag Event		Sub Open()		  SelectedThumbnailsDict.Clear()		  		  // Fire our custom event		  Open()		  		End Sub	#tag EndEvent	#tag Event		Sub Paint(g as Graphics, ForceUpdate as Boolean)		  // Repaint the whole canvas.		  		  dim r, c, index as integer		  		  // Buffer		  Buffer = new Picture(g.Width, g.Height, 32)		  		  // Calculate how many rows and columns are visible		  CalculateRowsAndColumns()		  		  // Work out the maximum scroll value		  CalculateMaxScrollValue()		  		  // Check for resizing errors		  if CurrentScrollValue > MaxScrollValue then		    CurrentScrollValue = MaxScrollValue		    FirstVisibleRow = CurrentScrollValue		  end if		  		  // ########## Background ########## \\		  Buffer.Graphics.ForeColor = BackgroundColor		  Buffer.Graphics.FillRect(0, 0, Buffer.Graphics.Width, Buffer.Graphics.Height)		  		  // ########## Thumbnails ##########\\		  if Thumbnails.Ubound < 0 then return ' no thumbnails to draw		  if Rows <= 0 or Columns <= 0 then return ' no room to draw		  		  // Which thumbnails should we update?		  UpdateVisibles(forceUpdate)		  		  // ##### Draw ##### \\		  // We'll draw from the top left corner to the bottom right corner		  index = 0		  for r = 0 to (rows-1)		    for c = 0 to (columns-1)		      if index > Visibles.Ubound then exit ' finished drawing		      DrawThumbnail(Visibles(index), Buffer.Graphics, r, c)		      index = index + 1		    next c		  next r		  		  // Fire the user's Paint event		  Paint(Buffer.Graphics)		  		  // Draw the buffer to the canvas		  g.DrawPicture(Buffer, 0, 0)		  		End Sub	#tag EndEvent	#tag Event		Sub SelectionChanged(SelectionRectangle as BoundsRectangle)		  // Loop through all of the visible thumbnails and determine if they fall within the selection rectangle		  		  dim a, index, limit as integer		  		  limit = Visibles.Ubound		  if limit < 0 then return ' nothing visible		  		  for a = 0 to limit		    index = Visibles(a)		    if Thumbnails(index).Intersects(selectionRectangle) then		      SelectionBuffer.Value(index) = 0		    elseif SelectionBuffer.HasKey(index) then		      SelectionBuffer.Remove(index)		    end if		  next a		  		  '// Fire the user's event		  'SelectionChanged()		  		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub AddThumbnail(Thumbnail as FGThumbnailClass)		  // This method adds the passed item to our array of managed items.		  		  // Append the thumbnail		  Thumbnails.Append(thumbnail)		  		  // Calculate the new maximum scroll value (since we've added an item)		  CalculateMaxScrollValue()		  		  // Fire our custom event		  ThumbnailCountChanged(ThumbnailCount)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub CalculateMaxScrollValue()		  // The maximum scroll value is the last row that can be show at the top of the canvas		  		  dim maxThumbnails as integer		  		  // How many thumbnails can fit on the canvas at the current zoom?		  maxThumbnails = Rows * Columns		  		  // Get the index of the thumbnail that would be the first thumbnail on this hypothetical row		  if (Thumbnails.Ubound - maxThumbnails) <= -1 then		    // All thumbnails are visible (no scrolling needed)		    MaxScrollValue = 0		  else		    // Scrolling is possible		    MaxScrollValue = ThumbnailRow(Thumbnails.Ubound-maxThumbnails) + 1		  end if		  		  MaxScrollValueChanged(MaxScrollValue, 1)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub CalculateRowsAndColumns()		  // Determine (at the current canvas size) how many COMPLETE columns and rows can be shown and set the required padding properties.		  		  dim totalColPadding, totalRowPadding as integer		  		  // ########################### Columns ###########################################################################		  // How many columns at the current zoom could possibly fit (wholly) on the canvas		  Columns = me.Width \ (CellSize + MinColumnPadding) ' note: integer divide		  		  // Calculate the total amount of pixels required to pad this many columns		  totalColPadding = me.Width - (Columns * (CellSize + MinColumnPadding))		  		  // Set the column padding		  ColumnPadding = totalColPadding \ (Columns - 1)		  		  // Make sure we don't exceed our maximum or minimum padding		  if ColumnPadding > MaxColumnPadding then ColumnPadding = MaxColumnPadding		  if ColumnPadding < MinColumnPadding then ColumnPadding = MinColumnPadding		  		  // Calculate the left inset		  LeftInset = (me.Width - (Columns * CellSize) - ((Columns - 1) * ColumnPadding)) / 2		  		  // ########################### Rows ##############################################################################		  // How many rows at the current zoom could possibly fit (wholly) on the canvas		  Rows = me.Height \ (CellSize + MinRowPadding) ' note: integer divide		  		  // Calculate the total amount of pixels required to pad this many rows		  totalRowPadding = me.Height - (Rows * (CellSize + MinRowPadding))		  		  // Set the column padding		  RowPadding = totalRowPadding \ (Rows - 1)		  		  // Make sure we don't exceed our maximum or minimum padding		  if RowPadding > MaxRowPadding then RowPadding = MaxRowPadding		  if RowPadding < MinRowPadding then RowPadding = MinRowPadding		  		  // Calculate the top inset		  TopInset = (me.Height - (Rows * CellSize) - ((Rows - 1) * RowPadding)) / 2		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Clear()		  // Remove all thumbnails from the canvas and update it.		  		  redim Thumbnails(-1)		  redim Visibles(-1)		  Refresh()		  		  // The number of thumbnails has changed		  ThumbnailCountChanged(ThumbnailCount)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Clear(Index as Integer)		  // Remove the thumbnail from the specified index (if it exists).		  		  if index < 0 or index > Thumbnails.Ubound then return		  		  Thumbnails.Remove(index)		  if Visibles.IndexOf(index) <> -1 then Visibles.Remove(index)		  		  Refresh()		  		  // The number of thumbnails has changed		  ThumbnailCountChanged(ThumbnailCount)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearSelection()		  // Remove the selected items from the canvas.		  		  dim indices(), index as integer		  		  if SelectedThumbnailsDict = nil then return ' shouldn't happen...		  		  if SelectedThumbnailsDict.Count < 1 then return ' no currently selected thumbnails to remove		  		  // Get the indices to remove from Thumbnails from the SelectedThumbnailsDict Dictionary		  for index = 0 to SelectedThumbnailsDict.Count - 1		    indices.Append(SelectedThumbnailsDict.Key(index))		  next index		  		  // Sort our array of indices		  indices.Sort()		  		  // Now loop through our indices and remove the corresponding objects from Thumbnails		  index = 0		  while indices.Ubound >= 0		    Thumbnails.Remove(indices(0) + index)		    indices.Remove(0)		    index = index - 1		  wend		  		  // Flag that nothing is selected anymore		  SelectedThumbnailsDict.Clear()		  		  // Since we've changed the number of thumbnails in the canvas - update the scroll values		  CalculateMaxScrollValue()		  		  Refresh()		  		  // Fire our custom event		  ThumbnailCountChanged(ThumbnailCount)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1000		Sub Constructor()		  // Calling the overridden superclass constructor.		  Super.Constructor		  		  // Initialise		  SelectedThumbnailsDict = new dictionary		  SelectionBuffer = new dictionary		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DeselectAll()		  SelectedIndex = -1		  Refresh()		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawThumbnail(ThumbnailIndex as Integer, g as Graphics, Row as Integer, Column as Integer)		  // This method draws the thumbnail at Thumbnail(ThumbnailIndex) to the passed Graphics object.		  // Row and Column specify the cell location on the canvas to draw to.		  		  dim x, y as integer		  dim selected as boolean = false		  dim selectionRect as new RoundRectShape		  		  if g = nil or ThumbnailIndex > Thumbnails.Ubound or row < 0 or row > (Rows-1) or column < 0 or column > (Columns-1) then return		  		  // Figure out the coordinates of the top-left corner of this cell		  x = (column * CellSize) + (ColumnPadding * column) + LeftInset		  y = (row * CellSize) + (RowPadding * row) + TopInset		  		  // Update this thumbnail's current bounds		  Thumbnails(ThumbnailIndex).Bounds(x, y, CellSize, CellSize)		  		  // Selected?		  if SelectionBuffer.Count > 0 and SelectionBuffer.HasKey(ThumbnailIndex) then selected = true		  if SelectedThumbnailsDict.HasKey(ThumbnailIndex) then selected = true		  		  // Draw the thumbnail's image to the calculated coordinates		  g.DrawPicture(Thumbnails(ThumbnailIndex).Image(selected), x, y)		  		  // Draw selection rectangle (if the user wants us to)		  if selected and DrawSelectionRectangle then		    selectionRect.X = x+ (CellSize/2)		    selectionRect.Y = y+ (CellSize/2)		    selectionRect.Width = CellSize		    selectionRect.Height = CellSize		    selectionRect.CornerWidth = 20		    selectionRect.CornerHeight = 20		    selectionRect.Fill = 0		    selectionRect.Border = 100		    selectionRect.BorderWidth = SelectedBorderThickness		    selectionRect.BorderColor = SelectedBorderColor		    g.DrawObject(selectionRect)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function FirstVisibleThumbnailIndex() As Integer		  // This method returns the index of the first visible thumbnail.  It will be the first item on the FirstVisibleRow.		  // We return -1 if there's a problem.		  		  if Thumbnails.Ubound < 0 or FirstVisibleRow < 0 then return -1		  		  // We simply need to multiply the number of thumbnails per row (Columns) by whatever row number is visible		  return (FirstVisibleRow * Columns)		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function IndexOfHighestSelectedThumbnail() As Integer		  // Looks at the currently selected thumbnails and returns the index of the highest one.		  		  dim indices(), index, limit as integer		  		  if SelectionCount < 1 then return -1 ' nothing currently selected		  		  limit = SelectedThumbnailsDict.Count-1		  for index = 0 to limit		    indices.Append(SelectedThumbnailsDict.Key(index))		  next index		  		  indices.Sort()		  		  return indices(indices.Ubound)		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function IndexOfLowestSelectedThumbnail() As Integer		  // Looks at the currently selected thumbnails and returns the index of the lowest one.		  		  dim indices(), index, limit as integer		  		  if SelectionCount < 1 then return -1 ' nothing currently selected		  		  limit = SelectedThumbnailsDict.Count-1		  for index = 0 to limit		    indices.Append(SelectedThumbnailsDict.Key(index))		  next index		  		  indices.Sort()		  		  return indices(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Scroll(RowsToScroll as Integer)		  // Scrolls the canvas by the specified number of rows.		  // Scroll up if negative, down if positive.		  		  dim totRows as integer		  		  // Calculate how many rows exist on the canvas (varies depending on canvas size and cellSize)		  totRows = TotalRowNumber()		  		  // Check that we've passed a valid scroll amount		  if (FirstVisibleRow + rowsToScroll) < 0 then		    FirstVisibleRow = 0		  elseif (rowsToScroll > 0 and (FirstVisibleRow = MaxScrollValue)) then		    FirstVisibleRow = MaxScrollValue		  else		    FirstVisibleRow = FirstVisibleRow + rowsToScroll		  end if		  		  // Update the current scroll value		  if FirstVisibleRow = 0 then		    CurrentScrollValue = 0		  elseif FirstVisibleRow > MaxScrollValue then		    FirstVisibleRow = MaxScrollValue		    CurrentScrollValue = MaxScrollValue		  else		    CurrentScrollValue = FirstVisibleRow		  end if		  ScrollValueChanged(CurrentScrollValue)		  		  // Update the canvas to reflect this scroll		  Refresh()		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ScrollDown(RowsToScroll as Integer = 1)		  // Scroll the canvas down the specified number of rows (defaults to one).		  		  if RowsToScroll = 0 then		    return		  else		    RowsToScroll = Abs(RowsToScroll)		  end if		  		  Scroll(RowsToScroll)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ScrollToRow(RowToScrollTo as Integer)		  if RowToScrollTo < 0 then		    RowToScrollTo = 0		  elseif RowToScrollTo > MaxScrollValue then		    RowToScrollTo = MaxScrollValue		  end if		  		  CurrentScrollValue = RowToScrollTo		  FirstVisibleRow = CurrentScrollValue		  Update()		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScrollToSelectedIndex()		  // Move to current selected thumbnail		  		  if SelectedIndex < 0 then return		  		  ScrollToRow(ThumbnailRow(SelectedIndex))		  Update()		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ScrollUp(RowsToScroll as Integer = 1)		  // Scroll the canvas up the specified number of rows (defaults to one).		  if RowsToScroll = 0 then		    return		  elseif RowsToScroll > 0 then		    RowsToScroll = 0 - RowsToScroll		  end if		  		  Scroll(RowsToScroll)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SelectAll()		  // Select every thumbnail.		  		  SelectRange(0, Thumbnails.Ubound)		  Refresh()		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function SelectedItemIndices() As Integer()		  // Returns a (sorted) array containing the indices of the thumbnails currently selected.		  		  dim indices(), index as integer		  		  if SelectedThumbnailsDict = nil then return indices ' shouldn't happen...		  		  for index = 0 to SelectedThumbnailsDict.Count - 1		    indices.Append(SelectedThumbnailsDict.Key(index))		  next index		  		  indices.Sort()		  		  return indices		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SelectedThumbnail() As FGThumbnailClass		  // Returns the currently selected thumbnail		  		  if SelectedIndex < 0 or SelectedIndex > Thumbnails.Ubound then		    return nil		  else		    return Thumbnails(SelectedIndex)		  end if		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SelectedThumbnails() As FGThumbnailClass()		  dim tmp() as FGThumbnailClass		  dim index, limit as integer		  		  if SelectionCount = 0 then return tmp		  		  limit = SelectedThumbnailsDict.Count-1		  for index = 0 to limit		    tmp.Append(Thumbnails(SelectedThumbnailsDict.Key(index)))		  next index		  		  return tmp		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SelectRange(Low as Integer, High as Integer)		  // Select a range of thumbnails whose indices are between low and high.		  		  dim index as integer		  		  // First clear all selected thumbnails		  SelectedThumbnailsDict.Clear()		  		  if low < 0 then low = 0		  if high > Thumbnails.Ubound  then high = Thumbnails.Ubound		  		  for index = low to high		    SelectedThumbnailsDict.Value(index) = 0		  next index		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function ThumbnailRow(Index as Integer) As Integer		  // This method takes the index of a thumbnail and returns the row it is on.		  		  if index = 0 then		    return 0		  else		    return Floor(index\Columns)		  end if		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function TotalRowNumber() As Integer		  // Returns the total number of rows on the canvas (not all of these will be shown at once).		  // Remember that the first row is 0 but this returns a count.		  		  dim answer as integer		  		  if Thumbnails.Ubound <= 0 then return 0 ' no thumbnails, therefore, no rows		  		  answer = ThumbnailCount\Columns		  if (ThumbnailCount mod Columns) <> 0 then answer = answer + 1		  		  return answer		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub UpdateVisibles(ForceUpdate as Boolean = False)		  // This method updates which thumbnails are currently visible on the canvas.		  		  dim a, firstThumbnailIndex, lastThumbnailIndex, nowVisible() as integer		  dim nowVisibleDict as new dictionary		  		  if Thumbnails.Ubound < 0 then return		  		  // Work out the indices of the first and last thumbnails that are currently visible		  firstThumbnailIndex = FirstVisibleThumbnailIndex		  lastThumbnailIndex = firstThumbnailIndex + (Rows * Columns)		  if lastThumbnailIndex > Thumbnails.Ubound then lastThumbnailIndex = Thumbnails.Ubound		  		  // Tell the visible thumbnails that they are visible and to update if necessary		  for a = firstThumbnailIndex to lastThumbnailIndex		    Thumbnails(a).Visible = true		    Thumbnails(a).Update(CellSize, forceUpdate)		    // Add all the now visible thumbnails to a temp array that we will use in a bit		    nowVisible.Append(a)		    // Use a dictionary to store the indices of the now visible thumbnails for quick checking		    nowVisibleDict.Value(a) = 0		  next a		  		  // Look at each thumbnail in Visible() and determine if it is no longer visible.  If that's the case - tell it so		  // This allows the FGThumbnail to free up any memory it might be consuming		  if Visibles.Ubound >= 0 then		    for a = 0 to Visibles.Ubound ' look at each thumbnail that was visible before we repainted		      if not nowVisibleDict.HasKey(Visibles(a)) then Thumbnails(Visibles(a)).Visible = false ' tell the ones that aren't visible anymore that they aren't!		    next a		  end if		  		  // Update the Visibles array by replacing it with our temp array		  redim Visibles(-1)		  if nowVisible.Ubound >= 0 then		    for a = 0 to nowVisible.Ubound		      Visibles.Append(nowVisible(a))		    next a		  end if		  		End Sub	#tag EndMethod	#tag Hook, Flags = &h0		Event ClickedThumbnail(Thumbnail as FGThumbnailClass, ContextualClick as Boolean = False, X as Integer = -1, Y as Integer = -1) As Boolean	#tag EndHook	#tag Hook, Flags = &h0		Event GotFocus()	#tag EndHook	#tag Hook, Flags = &h0		Event KeyDown(Key as String) As Boolean	#tag EndHook	#tag Hook, Flags = &h0		Event LostFocus()	#tag EndHook	#tag Hook, Flags = &h0		Event MaxScrollValueChanged(NewMaximum as Integer, NewPageStep as Integer)	#tag EndHook	#tag Hook, Flags = &h0		Event MouseDrag(X as Integer, Y as Integer, Thumbnails() as FGThumbnailClass)	#tag EndHook	#tag Hook, Flags = &h0		Event MouseExit()	#tag EndHook	#tag Hook, Flags = &h0		Event MouseMove(X as Integer, Y as Integer)	#tag EndHook	#tag Hook, Flags = &h0		Event MouseWheel(X as Integer, Y as Integer, deltaX as Integer, deltaY as Integer) As Boolean	#tag EndHook	#tag Hook, Flags = &h0		Event Open()	#tag EndHook	#tag Hook, Flags = &h0		Event Paint(g as Graphics)	#tag EndHook	#tag Hook, Flags = &h0		Event ScrollValueChanged(NewValue as Integer)	#tag EndHook	#tag Hook, Flags = &h0		Event SelectionChanged()	#tag EndHook	#tag Hook, Flags = &h0		Event ThumbnailCountChanged(NewCount as Integer)	#tag EndHook	#tag Property, Flags = &h0		AllowMouseWheelScrolling As Boolean	#tag EndProperty	#tag Property, Flags = &h0		BackgroundColor As Color	#tag EndProperty	#tag Property, Flags = &h21		Private Buffer As Picture	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mCellSize			End Get		#tag EndGetter		#tag Setter			Set			  // We're changing the size of the cells.  We need to figure out which thumbnail is now the first visible and recalculate our			  // scroll values based on this.			  			  dim oldFirstVisibleThumbnail as integer			  			  // Get the index of the first visible thumbnail before we resize anything (as this needs to be visible after the resize)			  oldFirstVisibleThumbnail = FirstVisibleThumbnailIndex			  			  // Update the cell size			  mCellSize = value			  			  // Recalculate the size of the rows and columns			  CalculateRowsAndColumns()			  			  // Determine which thumbnails are now visible			  UpdateVisibles()			  			  // Set the first row visible to be the row that contains the oldFirstVisibleThumbnail			  FirstVisibleRow = ThumbnailRow(oldFirstVisibleThumbnail)			  			  // CurrentScrollValue			  CalculateMaxScrollValue()			  // Update the current scroll value			  if FirstVisibleRow = 0 then			    CurrentScrollValue = 0			  else			    CurrentScrollValue = FirstVisibleRow			  end if			  ScrollValueChanged(CurrentScrollValue)			  			  // Update			  Refresh()			  			End Set		#tag EndSetter		CellSize As Integer	#tag EndComputedProperty	#tag Property, Flags = &h21		#tag Note			The current number of pixels that should pad each column (left and right of each cell).		#tag EndNote		Private ColumnPadding As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			How many columns are currently visible.		#tag EndNote		Private Columns As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private CurrentScrollValue As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mCurrentThumbnailUnderMouseIndex			End Get		#tag EndGetter		CurrentThumbnailUnderMouseIndex As Integer	#tag EndComputedProperty	#tag Property, Flags = &h0		DownKeyCode As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private Dragging As Boolean = False	#tag EndProperty	#tag Property, Flags = &h0		DrawSelectionRectangle As Boolean	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			The first visible row (zero-based).		#tag EndNote		Private FirstVisibleRow As Integer = 0	#tag EndProperty	#tag Property, Flags = &h0		ForceUpdateOnMouseMove As Boolean = True	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mInFocus			End Get		#tag EndGetter		InFocus As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		InvertMouseWheelScrollDirection As Boolean = True	#tag EndProperty	#tag Property, Flags = &h21		Private LastMouseX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private LastMouseY As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h21		#tag Getter			Get			  // Returns true if the last thumbnail is visible			  			  return Thumbnails(Thumbnails.Ubound).Visible			  			End Get		#tag EndGetter		Private LastThumbnailVisible As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h21		#tag Note			The number of pixels from the left of the canvas that drawing should start.		#tag EndNote		Private LeftInset As Integer	#tag EndProperty	#tag Property, Flags = &h0		LeftKeyCode As Integer	#tag EndProperty	#tag Property, Flags = &h0		MaxCellSize As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			The maximum number of pixels permitted between columns		#tag EndNote		MaxColumnPadding As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			The maximum number of pixels that should pad each row (top and bottom of each cell).		#tag EndNote		MaxRowPadding As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private MaxScrollValue As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			The canvas is carved up into rows and columns.  An intersection between the two is a cell and it's the area where an individual item is drawn to.			Cells are squares and, thus, CellSize is both the width and height of the cell in pixels.		#tag EndNote		Private mCellSize As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			This stores the index in Thumbnails() of the thumbnail under the mouse.  If there's none then it stores -1.		#tag EndNote		Private mCurrentThumbnailUnderMouseIndex As Integer = -1	#tag EndProperty	#tag Property, Flags = &h0		MinCellSize As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			The minimum number of pixels that should pad each column (left and right of each cell).		#tag EndNote		MinColumnPadding As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private mInFocus As Boolean = False	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			The minimum number of pixels that should pad each row (top and bottom of each cell).		#tag EndNote		MinRowPadding As Integer	#tag EndProperty	#tag Property, Flags = &h0		RightKeyCode As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			The current number of pixels that should pad each row (top and bottom of each cell).		#tag EndNote		Private RowPadding As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			How many rows are currently visible.		#tag EndNote		Private Rows As Integer	#tag EndProperty	#tag Property, Flags = &h0		SelectedBorderColor As Color	#tag EndProperty	#tag Property, Flags = &h0		SelectedBorderThickness As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h21		#tag Getter			Get			  if SelectedThumbnailsDict.Count > 0 then			    return SelectedThumbnailsDict.Key(0)			  else			    return -1			  end if			  			End Get		#tag EndGetter		#tag Setter			Set			  SelectedThumbnailsDict.Clear()			  			  if value < 0 then			    return			  end if			  			  SelectedThumbnailsDict.Value(value) = 0			End Set		#tag EndSetter		Private SelectedIndex As Integer	#tag EndComputedProperty	#tag Property, Flags = &h21		#tag Note			This dictionary stores the indices of any selected thumbnails as a Key.  The dictionary Value is irrelevant.		#tag EndNote		Private SelectedThumbnailsDict As Dictionary	#tag EndProperty	#tag Property, Flags = &h21		Private SelectionBuffer As Dictionary	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return SelectedThumbnailsDict.Count			  			End Get		#tag EndGetter		SelectionCount As Integer	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h21		#tag Getter			Get			  return Thumbnails.Ubound + 1			  			End Get		#tag EndGetter		Private ThumbnailCount As Integer	#tag EndComputedProperty	#tag Property, Flags = &h21		Private Thumbnails() As FGThumbnailClass	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			The number of pixels from the top of the canvas that drawing should start.		#tag EndNote		Private TopInset As Integer	#tag EndProperty	#tag Property, Flags = &h0		UpKeyCode As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			Stores the indices (in ascending order) of all the thumbnails currently visible on the canvas.		#tag EndNote		Private Visibles() As Integer	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="AcceptFocus"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AcceptTabs"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AllowMouseWheelScrolling"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="AutoDeactivate"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Backdrop"			Visible=true			Group="Appearance"			Type="Picture"			EditorType="Picture"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="BackgroundColor"			Visible=true			Group="Behavior"			InitialValue="&c676767"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="CellSize"			Visible=true			Group="Behavior"			InitialValue="128"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="CurrentThumbnailUnderMouseIndex"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="DoubleBuffer"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="DownKeyCode"			Visible=true			Group="Behavior"			InitialValue="31"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="DragSelectionBorder"			Visible=true			Group="Behavior"			InitialValue="2"			Type="Integer"			InheritedFrom="FGThumbnailCanvasSuper"		#tag EndViewProperty		#tag ViewProperty			Name="DragSelectionBorderColor"			Visible=true			Group="Behavior"			InitialValue="&cFFFFFF"			Type="Color"			InheritedFrom="FGThumbnailCanvasSuper"		#tag EndViewProperty		#tag ViewProperty			Name="DragSelectionColor"			Visible=true			Group="Behavior"			InitialValue="&cFFFFFF"			Type="Color"			InheritedFrom="FGThumbnailCanvasSuper"		#tag EndViewProperty		#tag ViewProperty			Name="DragSelectionOpacity"			Visible=true			Group="Behavior"			InitialValue="30"			Type="Integer"			InheritedFrom="FGThumbnailCanvasSuper"		#tag EndViewProperty		#tag ViewProperty			Name="DrawSelectionRectangle"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Enabled"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="EraseBackground"			Visible=true			Group="Behavior"			InitialValue="False"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="ForceUpdateOnMouseMove"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Height"			Visible=true			Group="Position"			InitialValue="300"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="HelpTag"			Visible=true			Group="Appearance"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="InFocus"			Group="Behavior"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="InitialParent"			Group="Initial State"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="InvertMouseWheelScrollDirection"			Visible=true			Group="Behavior"			InitialValue="False"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LeftKeyCode"			Visible=true			Group="Behavior"			InitialValue="28"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="LockBottom"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockLeft"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockRight"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockTop"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="MaxCellSize"			Visible=true			Group="Behavior"			InitialValue="256"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MaxColumnPadding"			Visible=true			Group="Behavior"			InitialValue="75"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MaxRowPadding"			Visible=true			Group="Behavior"			InitialValue="75"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MinCellSize"			Visible=true			Group="Behavior"			InitialValue="64"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MinColumnPadding"			Visible=true			Group="Behavior"			InitialValue="10"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="MinRowPadding"			Visible=true			Group="Behavior"			InitialValue="10"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="RightKeyCode"			Visible=true			Group="Behavior"			InitialValue="29"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="SelectedBorderColor"			Visible=true			Group="Behavior"			InitialValue="&c418CE5"			Type="Color"		#tag EndViewProperty		#tag ViewProperty			Name="SelectedBorderThickness"			Visible=true			Group="Behavior"			InitialValue="2"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Selecting"			Group="Behavior"			Type="Boolean"			InheritedFrom="FGThumbnailCanvasSuper"		#tag EndViewProperty		#tag ViewProperty			Name="SelectionCount"			Group="Behavior"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabIndex"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabPanelIndex"			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabStop"			Visible=true			Group="Position"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="UpKeyCode"			Visible=true			Group="Behavior"			InitialValue="30"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="UseFocusRing"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Visible"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Width"			Visible=true			Group="Position"			InitialValue="300"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass